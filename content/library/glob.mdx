---
title: Glob
description: Glob effect component.
date: 2024-03-04
published: true
---

# Glob

This component takes Orb to next level. As seen on the landing page, this component can be used to make your Next app shine.

## Preview

<ComponentPreview name="glob" />{" "}

## Code

Copy the following code to your component file for example **_glob.tsx_**.

<CodeBlockWrapper size="wrapper">
```tsx
import * as THREE from 'three';
import { useEffect, useRef } from 'react';
import { gsap } from 'gsap';

const AbstractBall: React.FC<any> = ({
  perlinTime = 25.0,
  perlinMorph = 25.0,
  perlinDNoise = 0.0,
  chromaRGBr = 7.5,
  chromaRGBg = 5.0,
  chromaRGBb = 7.0,
  chromaRGBn = 1.0,
  chromaRGBm = 1.0,
  sphereWireframe = false,
  spherePoints = false,
  spherePsize = 1.0,
  cameraSpeedY = 0.0,
  cameraSpeedX = 0.0,
  cameraZoom = 150,
  cameraGuide = false,
}) => {
  const mountRef = useRef<HTMLDivElement>(null);
  const sceneRef = useRef<THREE.Scene | null>(null);
  const cameraRef = useRef<THREE.PerspectiveCamera | null>(null);
  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);
  const materialRef = useRef<THREE.ShaderMaterial | null>(null);
  const meshRef = useRef<THREE.Mesh | null>(null);
  const pointRef = useRef<THREE.Points | null>(null);
  const uniformsRef = useRef<any>({
    time: { value: 0.0 },
    RGBr: { value: chromaRGBr / 10 },
    RGBg: { value: chromaRGBg / 10 },
    RGBb: { value: chromaRGBb / 10 },
    RGBn: { value: chromaRGBn / 100 },
    RGBm: { value: chromaRGBm },
    morph: { value: perlinMorph },
    dnoise: { value: perlinDNoise },
    psize: { value: spherePsize }
  });

  useEffect(() => {
    const width = mountRef.current!.clientWidth;
    const height = mountRef.current!.clientHeight;

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(20, width / height, 1, 1000);
    camera.position.set(0, 10, cameraZoom);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(width, height);
    renderer.shadowMap.enabled = true;
    mountRef.current!.appendChild(renderer.domElement);

    const geometry = new THREE.IcosahedronGeometry(20, 20);

    const material = new THREE.ShaderMaterial({
      uniforms: uniformsRef.current,
      side: THREE.DoubleSide,
      vertexShader: `
        varying vec3 vNormal;
        uniform float time;
        uniform float morph;
        uniform float psize;

        vec3 mod289(vec3 x) {
          return x - floor(x * (1.0 / 289.0)) * 289.0;
        }

        vec4 permute(vec4 x) {
          return mod289(((x * 34.0) + 1.0) * x);
        }

        float cnoise(vec3 P) {
          vec3 Pi0 = floor(P);
          vec3 Pf0 = fract(P);
          vec3 Pf1 = Pf0 - vec3(1.0);
          float n_xyz = dot(Pf0, Pf1);
          return 1.2 * n_xyz;
        }

        void main() {
          float f = morph * cnoise(normal + time);
          vNormal = normalize(normal);
          vec4 pos = vec4(position + f * normal, 1.0);
          gl_Position = projectionMatrix * modelViewMatrix * pos;
          gl_PointSize = psize;
        }`,
      fragmentShader: `
        varying vec3 vNormal;
        uniform float time;
        uniform float RGBr;
        uniform float RGBg;
        uniform float RGBb;
        uniform float RGBn;
        uniform float RGBm;
        uniform float dnoise;

        vec3 mod289(vec3 x) {
          return x - floor(x * (1.0 / 289.0)) * 289.0;
        }

        float cnoise(vec3 P) {
          vec3 Pi0 = floor(P);
          vec3 Pf0 = fract(P);
          vec3 Pf1 = Pf0 - vec3(1.0);
          float n_xyz = dot(Pf0, Pf1);
          return 2.2 * n_xyz;
        }

        void main() {
          float r = cnoise(RGBr * (vNormal + time));
          float g = cnoise(RGBg * (vNormal + time));
          float b = cnoise(RGBb * (vNormal + time));
          float n = 50.0 * cnoise((RGBn) * (vNormal)) * cnoise(RGBm * (vNormal + time));
          n -= 0.10 * cnoise(dnoise * vNormal);
          vec3 color = vec3(r + n, g + n, b + n);
          gl_FragColor = vec4(color, 1.0);
        }`,
      wireframe: sphereWireframe,
    });

    const mesh = new THREE.Mesh(geometry, material);
    const point = new THREE.Points(geometry, material);

    mesh.castShadow = true;
    mesh.receiveShadow = true;
    mesh.geometry.morphTargetsRelative = true;

    scene.add(mesh);
    scene.add(point);

    let lastFrameTime = performance.now(); // Store the time of the last frame

    const animate = () => {
      const currentFrameTime = performance.now(); // Get the current time
      const delta = (currentFrameTime - lastFrameTime) / 1000; // Time difference in seconds
      lastFrameTime = currentFrameTime; // Update the last frame time

      // Update the time based on the delta, which normalizes the animation speed
      uniformsRef.current.time.value += delta * perlinTime;

      // Update other uniforms and mesh properties as before
      uniformsRef.current.morph.value = perlinMorph;
      uniformsRef.current.dnoise.value = perlinDNoise;

      uniformsRef.current.RGBr.value = chromaRGBr / 10;
      uniformsRef.current.RGBg.value = chromaRGBg / 10;
      uniformsRef.current.RGBb.value = chromaRGBb / 10;
      uniformsRef.current.RGBn.value = chromaRGBn / 100;
      uniformsRef.current.RGBm.value = chromaRGBm;
      uniformsRef.current.psize.value = spherePsize;

      mesh.rotation.y += (cameraSpeedY / 100) * delta; // Adjust rotations using delta
      mesh.rotation.z += (cameraSpeedX / 100) * delta;
      point.rotation.y = mesh.rotation.y;
      point.rotation.z = mesh.rotation.z;

      material.wireframe = sphereWireframe;
      mesh.visible = !spherePoints;
      point.visible = spherePoints;

      camera.lookAt(scene.position);
      renderer.render(scene, camera);

      requestAnimationFrame(animate); // Schedule the next frame
    };

    animate();

    const handleResize = () => {
      const width = mountRef.current!.clientWidth;
      const height = mountRef.current!.clientHeight;
      renderer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    };
    window.addEventListener('resize', handleResize);

    sceneRef.current = scene;
    cameraRef.current = camera;
    rendererRef.current = renderer;
    materialRef.current = material;
    meshRef.current = mesh;
    pointRef.current = point;

    return () => {
      window.removeEventListener('resize', handleResize);
      if (mountRef.current) {
        mountRef.current.removeChild(renderer.domElement);
      }
      renderer.dispose();
    };
  }, [
    perlinTime,
    perlinMorph,
    perlinDNoise,
    chromaRGBr,
    chromaRGBg,
    chromaRGBb,
    chromaRGBn,
    chromaRGBm,
    sphereWireframe,
    spherePoints,
    spherePsize,
    cameraSpeedY,
    cameraSpeedX,
    cameraZoom,
  ]);

  // Using gsap for animations
  useEffect(() => {
    if (cameraRef.current) {
      gsap.to(cameraRef.current.position, {
        duration: 2,
        z: 300 - cameraZoom,
      });
    }
    gsap.to(uniformsRef.current.RGBr, { duration: 1, value: Math.random() * 10 });
    gsap.to(uniformsRef.current.RGBg, { duration: 1, value: Math.random() * 10 });
    gsap.to(uniformsRef.current.RGBb, { duration: 1, value: Math.random() * 10 });
    gsap.to(uniformsRef.current.RGBn, { duration: 1, value: Math.random() * 2 });
    gsap.to(uniformsRef.current.RGBm, { duration: 1, value: Math.random() * 5 });
  }, [cameraZoom]);

  return (
    <div ref={mountRef} style={{ width: '100%', height: '500px' }} className='rounded-2xl mt-2'></div>
  );
};

export default AbstractBall;


````
</CodeBlockWrapper>


## Usage

Import the component in your file and then use it in your page. Ensure Vapi hook is setup.

**_Note:_** This component uses Tailwind CSS, make sure to have it installed in your project.

<CodeBlockWrapper size="full">
```tsx {1,6}
import React, { useState, useEffect } from 'react';
import AbstractBall from '@/components/examples/abstract-ball';
import useVapi from '@/hooks/use-vapi';
import { Button } from '@/components/ui/button';
import { MicIcon, PhoneOff } from 'lucide-react';

const ParentComponent: React.FC = () => {
  const { volumeLevel, isSessionActive, toggleCall } = useVapi();
  const [config, setConfig] = useState({
    perlinTime: 50.0,
    perlinDNoise: 2.5,
    chromaRGBr: 7.5,
    chromaRGBg: 5,
    chromaRGBb: 7,
    chromaRGBn: 0,
    chromaRGBm: 1.0,
    sphereWireframe: false,
    spherePoints: false,
    spherePsize: 1.0,
    cameraSpeedY: 0.0,
    cameraSpeedX: 0.0,
    cameraZoom: 175,
    cameraGuide: false,
    perlinMorph: 5.5,
  });

  useEffect(() => {
    if (isSessionActive && volumeLevel > 0) {
      setConfig(prevConfig => ({
        ...prevConfig,
        perlinTime: 100.0,
        perlinMorph: 25.0,
      }));
    } 
    else{ 
      if (isSessionActive) {
        setConfig(prevConfig => ({
          ...prevConfig,
          perlinTime: 25.0,
          perlinMorph: 10.0,
        }));
      }
      else{
      setConfig(prevConfig => ({
        ...prevConfig,
        perlinTime: 5.0,
        perlinMorph: 0,
      }));
      }
    }
  }, [isSessionActive, volumeLevel]);

  return (
    <div style={{ width: '100%', height: '100%' }}>
      <ConfigSheet config={config} setConfig={setConfig} />
      <AbstractBall {...config} />
      <div className="flex justify-center mt-4">
        <Button onClick={toggleCall} className='m-2'>
          {isSessionActive ? <PhoneOff size={18} /> : <MicIcon size={18} />}
        </Button>
      </div>
    </div>
  );
};

export default ParentComponent;

````

</CodeBlockWrapper>
